package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"path"
	"strings"
	"text/template"

	"github.com/ameliaikeda/protoc-gen-router/service"
	"github.com/monzo/terrors"
	"google.golang.org/protobuf/compiler/protogen"
)

const routerTmpl = `// Code generated by protoc-gen-router; DO NOT EDIT.

// Package {{ .Package }} is a Google protocol buffer interface to this service.
// See {{ .Host }}.proto for a full description of this service's protobuf interface.
// To use the router functionality of this service, call a request struct's receivers in the following manner:
//
//		rsp, err := {{ .Package }}.GetFooRequest{
//			Id: "bar",
//		}.Send(ctx).DecodeResponse()
package {{ .Package }}

import (
	"context"
    "github.com/monzo/typhon"
)

{{- range .RPCs }}
    // -------------------------
    // {{ .Method }} /{{ $.Host }}{{ .Path }}
    // -------------------------
    // Method is the HTTP method used for this request.
    // It is inferred from the name of the Request using a prefix match.
    func (body *{{ .Request }}) Method() string {
        return "{{ .Method }}"
    }

    // Path is the HTTP path to this endpoint
    func (body *{{ .Request }}) Path() string {
        return "{{ .Path }}"
    }

    // ServiceName is the long-form service name, e.g. service.brand.
    func (body *{{ .Request }}) ServiceName() string {
        return "{{ $.Host }}"
    }

    // Host is the short-form service name, e.g. s-brand.
    func (body *{{ .Request }}) Host() string {
        return "{{ $.Host }}"
    }

    // FullPath is the full routable URL to this service.
    func (body *{{ .Request }}) FullPath() string {
        return "http://{{ $.Host }}{{ .Path }}"
    }

    // Request returns a typhon request for this type.
    func (body *{{ .Request }}) Request(ctx context.Context) typhon.Request {
        return typhon.NewRequest(ctx, body.Method(), body.FullPath(), body)
    }

    // Response is a shortcut for .Send(ctx).DecodeResponse(), for when you do not need a future.
    // This saves on boilerplate throughout the codebase and you should use this method unless you need parallel requests.
    func (body *{{ .Request }}) Response(ctx context.Context) (*{{ .Response }}, error) {
        return body.Send(ctx).DecodeResponse()
    }

    // Send creates a typhon future and immediately returns it.
    // To wait for the request to complete and return the response, use DecodeResponse on the returned future.
    func (body *{{ .Request }}) Send(ctx context.Context) *{{ .Future }} {
        return &{{ .Future }}{Future: body.Request(ctx).Send()}
    }

	// SendVia creates a typhon future and immediately returns it, passing the request through svc.
	// To wait for the request to complete and return the response, use DecodeResponse on the returned future.
	func (body *{{ .Request }}) SendVia(ctx context.Context, svc typhon.Service) *{{ .Future }} {
		return &{{ .Future }}{Future: body.Request(ctx).SendVia(svc)}
	}

    // {{ .Future }} is an intermediate future used for parallel requests with {{ .Request }}
    type {{ .Future }} struct {
        Future   *typhon.ResponseFuture
        Response *typhon.Response
    }

    // Done waits for a response from a typhon future, and is safe to call multiple times in a row.
    func (f *{{ .Future }}) Done() {
        if f.Response == nil {
            rsp := f.Future.Response()
            f.Response = &rsp
        }
    }

    // DecodeResponse waits for this future to be done and then decodes the response into a concrete type.
    func (f *{{ .Future }}) DecodeResponse() (*{{ .Response }}, error) {
        f.Done()
        body := &{{ .Response }}{}
        if err := f.Response.Decode(body); err != nil {
            return nil, err
        }
		return body, nil
    }
{{- end }}
`

var router = template.Must(template.New("protoc-gen-router").Parse(routerTmpl))

func GenerateRouter(plugin *protogen.Plugin, svc *service.Service) error {
	var buf bytes.Buffer
	if err := router.Execute(&buf, svc); err != nil {
		return terrors.WrapWithCode(err, nil, "template.router")
	}

	b, err := format.Source(buf.Bytes())
	if err != nil {
		return terrors.WrapWithCode(err, nil, "template.router.format_source")
	}

	filename := strings.Replace(path.Base(svc.Filename), ".proto", ".router.go", 1)
	f := plugin.NewGeneratedFile(svc.Directory+"/proto/"+filename, protogen.GoImportPath(svc.FullPackage))

	written, err := f.Write(b)
	if err != nil {
		return terrors.WrapWithCode(err, nil, "template.router.write_file_failed")
	}

	if written != len(b) {
		return terrors.New("template.router.write_file_incomplete", fmt.Sprintf("Expected %d bytes written, got %d", len(b), written), nil)
	}

	return nil
}
